function res = NDN_getSub_M_DFC(app)
% FORMAT NDN_getSub_M_DFC(app)
% NDN_getSub_M_DFC calculates the mean and median values for each of the k
% states for every subject. Also, If calculates the variability for each subject. 
% If a subject does not have state i, the corresponding position is assigned a value of all zeros.

% INPUT:
% app               - A structure containing the following fields:
%    app.stateTransition - A matrix of shape (N_sub, N_win), where N_sub is
%                          the number of subjects and N_win is the number of
%                          windows. Each row represents the state transition
%                          of a subject over N_win windows, obtained from
%                          Step 3 clustering.
%    app.allState      - A matrix of shape (N_roi, N_roi, K), where N_roi is
%                        the number of ROIs and K is the number of states.
%    app.dFC_result_3D - A 3D matrix of shape (N_win, (N_roi * N_roi) or
%                        (N_roi * (N_roi - 1))/2, N_sub). The second
%                        dimension: If the LOO method is used, it is
%                        (N_roi * N_roi) because the functional
%                        connectivity generated by this method is asymmetric.
%                        Otherwise, it is symmetric. The LOO method
%                        correlates the data with the LOO mean.
%    app.info.ISA_type - (Optional) A string indicating the type of
%                        Inter-Subject Analysis (ISA). Valid values are 'LOO'
%                        or 'regressLOO'.

% OUTPUT:
% The calculated values will be saved in the following fields of the app
% structure:
%    app.mean        - A structure containing the mean values for each
%                      subject and each state. For example, the mean value
%                      of the k-th state for the first subject is saved in
%                      app.mean.sub01 = submean, where submean has the shape
%                      (N_roi, N_roi, K).
%    app.median      - A structure containing the median values for each
%                      subject and each state. For example, the median value
%                      of the k-th state for the first subject is saved in
%                      app.median.sub01 = submedian, where submedian has the
%                      shape (N_roi, N_roi, K).
%    app.variability   - A structure containing the std values for each
%                      subject . For example, the std value for the first subject is saved in
%                      app.variability.sub01 = subvariability, where subvariability has the
%                      shape (N_roi, N_roi).

stateTransition = app.stateTransition;
allState = app.allState;
% Get the dimensions of the input parameters
N_sub = size(app.stateTransition, 1); % Number of subjects
N_roi = size(app.allState, 1); % Number of ROIs
K = size(allState, 3); % Number of states

% Initialize output variables
app.mean = struct(); % To store the mean values for each subject and each state
app.median = struct(); % To store the median values for each subject and each state
app.variability = struct(); % To store the std values for each subject


% Loop through each subject
for sub = 1:N_sub
    % Initialize the mean and median matrices for the current subject
    submean = zeros(N_roi, N_roi, K); % Mean matrix
    submedian = zeros(N_roi, N_roi, K); % Median matrix
    subvariability = zeros(N_roi, N_roi); % variability matrix

    % Get the state transition sequence for the current subject
    subStateTransition = stateTransition(sub, :);
    subDFC = squeeze(app.dFC_result_3D(:, :, sub));
    tmpSubvariability = std(subDFC, 0, 1);
    % Check if LOO method is used
    if isfield(app.info, "ISA_type") && isequal(app.info.ISA_type, 'LOO')
        subvariability = sf_vec2mat_Asy(N_roi, tmpSubvariability(:));
    else
        subvariability = sf_vec2mat(N_roi, tmpSubvariability(:));
        subvariability = subvariability + subvariability';
    end
    % Loop through each state
    for k = 1:K
        % Find the window indices corresponding to the current state k
        state_k_indices = find(subStateTransition == k);
        
        % If the current state k exists
        if ~isempty(state_k_indices)
            % Extract the DFC data corresponding to the current state k
            dFC_k = squeeze(app.dFC_result_3D(state_k_indices, :, sub));
            
            % Calculate the mean and median
            tmpSubMean = mean(dFC_k, 1); % Calculate the mean
            tmpSubMedium = median(dFC_k, 1); % Calculate the median

            % Check if LOO method is used
            if isfield(app.info, "ISA_type") && isequal(app.info.ISA_type, 'LOO')
                tmp_state_mean = sf_vec2mat_Asy(N_roi, tmpSubMean(:));
                tmp_state_medium = sf_vec2mat_Asy(N_roi, tmpSubMedium(:));
            else
                tmp_state_mean = sf_vec2mat(N_roi, tmpSubMean(:));
                tmp_state_mean = tmp_state_mean + tmp_state_mean';
                tmp_state_medium = sf_vec2mat(N_roi, tmpSubMedium(:));
                tmp_state_medium = tmp_state_medium + tmp_state_medium';
            end
            submean(:, :, k)  = tmp_state_mean;
            submedian(:, :, k)  = tmp_state_medium;
        else
            % If the current state k does not exist, assign a value of all zeros
            submean(:, :, k) = zeros(N_roi, N_roi);
            submedian(:, :, k) = zeros(N_roi, N_roi);
        end
    end
    num = num2str(length(num2str(N_sub)));
    % Save the results for the current subject in app
    app.mean.(sprintf(['sub%0' num 'd'], sub)) = submean;
    app.median.(sprintf(['sub%0' num 'd'], sub)) = submedian;
    app.variability.(sprintf(['sub%0' num 'd'], sub)) = subvariability;

    res = app;
end

end